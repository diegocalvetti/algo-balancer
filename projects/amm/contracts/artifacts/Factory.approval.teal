#pragma version 10
intcblock 8 1 0 6 4096 2
bytecblock 0x 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f 0x706f6f6c735f 0x6d616e61676572 0xb8447b36 0x151f7c75

// This TEAL was generated by TEALScript v0.106.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 3 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
//
// createApplication method called at creation
createApplication:
	proto 0 0

	// contracts/Factory.algo.ts:25
	// this.manager.value = this.app.creator
	bytec 3 //  "manager"
	txna Applications 0
	app_params_get AppCreator
	pop
	app_global_put
	retsub

// createPool()void
*abi_route_createPool:
	// execute createPool()void
	callsub createPool
	intc 1 // 1
	return

// createPool(): void
//
// Deploy the pool contract, compiled teal of the contract
// must be loaded in poolContractApprovalProgram
createPool:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/Factory.algo.ts:33
	// for (let i = 0; i < 8; i += 1)
	intc 2 // 0
	frame_bury 0 // i: uint64

*for_0:
	// contracts/Factory.algo.ts:33
	// i < 8
	frame_dig 0 // i: uint64
	intc 0 // 8
	<
	bz *for_0_end

	// *if0_condition
	// contracts/Factory.algo.ts:34
	// !this.poolContractApprovalProgram(i).exists
	bytec 1 //  "pool_approval_program_page_"
	frame_dig 0 // i: uint64
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if0_end

	// *if0_consequent
	// contracts/Factory.algo.ts:35
	// this.poolContractApprovalProgram(i).value = ''
	bytec 1 //  "pool_approval_program_page_"
	frame_dig 0 // i: uint64
	itob
	concat
	dup
	box_del
	pop
	bytec 0 //  ""
	box_put

*if0_end:

*for_0_continue:
	// contracts/Factory.algo.ts:33
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_0

*for_0_end:
	// contracts/Factory.algo.ts:39
	// sendAppCall({
	//       onCompletion: OnCompletion.NoOp,
	//       approvalProgram: [
	//         this.poolContractApprovalProgram(0).value,
	//         this.poolContractApprovalProgram(1).value,
	//         this.poolContractApprovalProgram(2).value,
	//         this.poolContractApprovalProgram(3).value,
	//         this.poolContractApprovalProgram(4).value,
	//         this.poolContractApprovalProgram(5).value,
	//         this.poolContractApprovalProgram(6).value,
	//         this.poolContractApprovalProgram(7).value,
	//       ],
	//       clearStateProgram: AssetVault.clearProgram(),
	//       globalNumUint: AssetVault.schema.global.numUint,
	//       globalNumByteSlice: AssetVault.schema.global.numByteSlice,
	//       extraProgramPages: 3,
	//       applicationArgs: [method('createApplication()void')],
	//       fee: 100_000,
	//     })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum

	// contracts/Factory.algo.ts:40
	// onCompletion: OnCompletion.NoOp
	intc 2 //  NoOp
	itxn_field OnCompletion

	// contracts/Factory.algo.ts:41
	// approvalProgram: [
	//         this.poolContractApprovalProgram(0).value,
	//         this.poolContractApprovalProgram(1).value,
	//         this.poolContractApprovalProgram(2).value,
	//         this.poolContractApprovalProgram(3).value,
	//         this.poolContractApprovalProgram(4).value,
	//         this.poolContractApprovalProgram(5).value,
	//         this.poolContractApprovalProgram(6).value,
	//         this.poolContractApprovalProgram(7).value,
	//       ]
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000000
	box_get

	// box value does not exist: this.poolContractApprovalProgram(0).value
	assert
	itxn_field ApprovalProgramPages
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000001
	box_get

	// box value does not exist: this.poolContractApprovalProgram(1).value
	assert
	itxn_field ApprovalProgramPages
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000002
	box_get

	// box value does not exist: this.poolContractApprovalProgram(2).value
	assert
	itxn_field ApprovalProgramPages
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000003
	box_get

	// box value does not exist: this.poolContractApprovalProgram(3).value
	assert
	itxn_field ApprovalProgramPages
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000004
	box_get

	// box value does not exist: this.poolContractApprovalProgram(4).value
	assert
	itxn_field ApprovalProgramPages
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000005
	box_get

	// box value does not exist: this.poolContractApprovalProgram(5).value
	assert
	itxn_field ApprovalProgramPages
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000006
	box_get

	// box value does not exist: this.poolContractApprovalProgram(6).value
	assert
	itxn_field ApprovalProgramPages
	pushbytes 0x706f6f6c5f617070726f76616c5f70726f6772616d5f706167655f0000000000000007
	box_get

	// box value does not exist: this.poolContractApprovalProgram(7).value
	assert
	itxn_field ApprovalProgramPages

	// contracts/Factory.algo.ts:51
	// clearStateProgram: AssetVault.clearProgram()
	pushbytes 0x0a
	itxn_field ClearStateProgram

	// contracts/Factory.algo.ts:52
	// globalNumUint: AssetVault.schema.global.numUint
	pushint 4
	itxn_field GlobalNumUint

	// contracts/Factory.algo.ts:53
	// globalNumByteSlice: AssetVault.schema.global.numByteSlice
	intc 5 // 2
	itxn_field GlobalNumByteSlice

	// contracts/Factory.algo.ts:54
	// extraProgramPages: 3
	pushint 3
	itxn_field ExtraProgramPages

	// contracts/Factory.algo.ts:55
	// applicationArgs: [method('createApplication()void')]
	bytec 4 //  method "createApplication()void"
	itxn_field ApplicationArgs

	// contracts/Factory.algo.ts:56
	// fee: 100_000
	pushint 100_000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// initPool(uint64,uint64[],uint64[])uint64
*abi_route_initPool:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// weights: uint64[]
	txna ApplicationArgs 3
	extract 2 0

	// assetIds: uint64[]
	txna ApplicationArgs 2
	extract 2 0

	// poolID: uint64
	txna ApplicationArgs 1
	btoi

	// execute initPool(uint64,uint64[],uint64[])uint64
	callsub initPool
	itob
	concat
	log
	intc 1 // 1
	return

// initPool(poolID: AppID, assetIds: AssetID[], weights: uint64[]): AssetID
//
// Initialize the pool with the given assets & weights
// @param {AppID} poolID - Pool App ID
// @param {AssetID[]} assetIds
// @param {uint64[]} weights
initPool:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/Factory.algo.ts:68
	// assert(assetIds.length >= 2, 'At least 2 tokens needed')
	frame_dig -2 // assetIds: AssetID[]
	len
	intc 0 // 8
	/
	intc 5 // 2
	>=

	// At least 2 tokens needed
	assert

	// contracts/Factory.algo.ts:69
	// assert(assetIds.length === weights.length, 'Weights and Assets length must be the same')
	frame_dig -2 // assetIds: AssetID[]
	len
	intc 0 // 8
	/
	frame_dig -3 // weights: uint64[]
	len
	intc 0 // 8
	/
	==

	// Weights and Assets length must be the same
	assert

	// contracts/Factory.algo.ts:71
	// hash = this.getPoolHash(assetIds, weights)
	frame_dig -3 // weights: uint64[]
	frame_dig -2 // assetIds: AssetID[]
	callsub getPoolHash
	frame_bury 0 // hash: byte[32]

	// contracts/Factory.algo.ts:73
	// assert(!this.pools(hash).exists, 'This pool already exists')
	bytec 2 //  "pools_"
	frame_dig 0 // hash: byte[32]
	concat
	box_len
	swap
	pop
	!

	// This pool already exists
	assert

	// contracts/Factory.algo.ts:75
	// this.pools(hash).value = { id: poolID, assets: assetIds, weights: weights }
	bytec 2 //  "pools_"
	frame_dig 0 // hash: byte[32]
	concat
	dup
	box_del
	pop
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x000c // initial head offset
	frame_dig -1 // poolID: AppID
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // assetIds: AssetID[]
	dup
	len
	intc 0 // 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // weights: uint64[]
	dup
	len
	intc 0 // 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/Factory.algo.ts:77
	// return sendMethodCall<typeof AssetVault.prototype.bootstrap, AssetID>({
	//       applicationID: poolID,
	//       methodArgs: [assetIds, weights],
	//     });
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xe635fdb5 // method "bootstrap(uint64[],uint64[])uint64"
	itxn_field ApplicationArgs

	// contracts/Factory.algo.ts:78
	// applicationID: poolID
	frame_dig -1 // poolID: AppID
	itxn_field ApplicationID

	// contracts/Factory.algo.ts:79
	// methodArgs: [assetIds, weights]
	frame_dig -2 // assetIds: AssetID[]
	dup
	len
	intc 0 // 8
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -3 // weights: uint64[]
	dup
	len
	intc 0 // 8
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// opUp()void
*abi_route_opUp:
	// execute opUp()void
	callsub opUp
	intc 1 // 1
	return

// opUp(): void
opUp:
	proto 0 0
	retsub

// MANAGER_writePoolContractProgram(uint64,byte[])void
*abi_route_MANAGER_writePoolContractProgram:
	// data: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// offset: uint64
	txna ApplicationArgs 1
	btoi

	// execute MANAGER_writePoolContractProgram(uint64,byte[])void
	callsub MANAGER_writePoolContractProgram
	intc 1 // 1
	return

// MANAGER_writePoolContractProgram(offset: uint64, data: bytes): void
//
// *******************
// MANAGER
// *******************
MANAGER_writePoolContractProgram:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/Factory.algo.ts:89
	// this.assertIsManager()
	callsub assertIsManager

	// contracts/Factory.algo.ts:91
	// pageIndex = (offset + 4096 - 1) / 4096
	frame_dig -1 // offset: uint64
	intc 4 // 4096
	+
	intc 1 // 1
	-
	intc 4 // 4096
	/
	frame_bury 0 // pageIndex: uint64

	// contracts/Factory.algo.ts:92
	// this.poolContractApprovalProgram(pageIndex).value = data
	bytec 1 //  "pool_approval_program_page_"
	frame_dig 0 // pageIndex: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -2 // data: bytes
	box_put
	retsub

// assertIsManager(): void
//
// *******************
// SUBROUTINES
// *******************
assertIsManager:
	proto 0 0

	// contracts/Factory.algo.ts:100
	// assert(this.txn.sender === this.manager.value, 'only the manager can call this method')
	txn Sender
	bytec 3 //  "manager"
	app_global_get
	==

	// only the manager can call this method
	assert
	retsub

// getPoolHash(assetIds: AssetID[], weights: uint64[]): bytes32
getPoolHash:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/Factory.algo.ts:104
	// parts: bytes = ''
	bytec 0 //  ""
	frame_bury 0 // parts: bytes

	// contracts/Factory.algo.ts:106
	// for (let i = 0; i < assetIds.length; i += 1)
	intc 2 // 0
	frame_bury 1 // i: uint64

*for_1:
	// contracts/Factory.algo.ts:106
	// i < assetIds.length
	frame_dig 1 // i: uint64
	frame_dig -1 // assetIds: AssetID[]
	len
	intc 0 // 8
	/
	<
	bz *for_1_end

	// contracts/Factory.algo.ts:107
	// parts += itob(assetIds[i])
	frame_dig 0 // parts: bytes
	frame_dig -1 // assetIds: AssetID[]
	store 255 // full array
	intc 2 //  initial offset
	frame_dig 1 // i: uint64
	intc 0 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 0 // 8
	extract3
	btoi
	itob
	concat
	frame_bury 0 // parts: bytes

	// contracts/Factory.algo.ts:108
	// parts += itob(weights[i])
	frame_dig 0 // parts: bytes
	frame_dig -2 // weights: uint64[]
	store 255 // full array
	intc 2 //  initial offset
	frame_dig 1 // i: uint64
	intc 0 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 0 // 8
	extract3
	btoi
	itob
	concat
	frame_bury 0 // parts: bytes

*for_1_continue:
	// contracts/Factory.algo.ts:106
	// i += 1
	frame_dig 1 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // i: uint64
	b *for_1

*for_1_end:
	// contracts/Factory.algo.ts:111
	// return sha512_256(parts);
	frame_dig 0 // parts: bytes
	sha512_256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// min(a: uint64, b: uint64): uint64
min:
	proto 2 1

	// contracts/Factory.algo.ts:115
	// return a > b ? a : b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	>
	bz *ternary0_false
	frame_dig -1 // a: uint64
	b *ternary0_end

*ternary0_false:
	frame_dig -2 // b: uint64

*ternary0_end:
	retsub

// getPool(uint64[],uint64[])(uint64,uint64[],uint64[])
*abi_route_getPool:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// weights: uint64[]
	txna ApplicationArgs 2
	extract 2 0

	// assetIds: uint64[]
	txna ApplicationArgs 1
	extract 2 0

	// execute getPool(uint64[],uint64[])(uint64,uint64[],uint64[])
	callsub getPool
	concat
	log
	intc 1 // 1
	return

// getPool(assetIds: AssetID[], weights: uint64[]): Pool
getPool:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/Factory.algo.ts:120
	// hash = this.getPoolHash(assetIds, weights)
	frame_dig -2 // weights: uint64[]
	frame_dig -1 // assetIds: AssetID[]
	callsub getPoolHash
	frame_bury 0 // hash: byte[32]

	// contracts/Factory.algo.ts:121
	// return this.pools(hash).value;
	bytec 2 //  "pools_"
	frame_dig 0 // hash: byte[32]
	concat
	box_get

	// box value does not exist: this.pools(hash).value
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

*create_NoOp:
	txn NumAppArgs
	bz *abi_route_createApplication
	bytec 4 //  method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x42588e09 // method "createPool()void"
	pushbytes 0xa1eb3020 // method "initPool(uint64,uint64[],uint64[])uint64"
	pushbytes 0x854dede0 // method "opUp()void"
	pushbytes 0xa4b503c1 // method "MANAGER_writePoolContractProgram(uint64,byte[])void"
	pushbytes 0xc9911396 // method "getPool(uint64[],uint64[])(uint64,uint64[],uint64[])"
	txna ApplicationArgs 0
	match *abi_route_createPool *abi_route_initPool *abi_route_opUp *abi_route_MANAGER_writePoolContractProgram *abi_route_getPool

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub